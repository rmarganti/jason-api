import { equals, omit, pick } from 'ramda';
import { connect, Dispatch } from 'react-redux';
import {
    compose,
    ComponentEnhancer,
    lifecycle,
    withHandlers,
    withState,
    mapProps,
    withStateHandlers,
} from 'recompose';
import { ActionCreator, Action } from 'redux';
import { iJsonApiResponse } from 'ts-json-api';

import { iJsonApiActionConfig } from '../interfaces/Middleware';
import { iStateWithJasonApi } from '../interfaces/state';
import { cacheQuery } from '../redux/actions';
import { getCachedQuery } from '../redux/selectors';
import { hashObject } from '../utils/data';

export interface iWithQueryOptions {
    actionCreator: (
        dispatch: Dispatch<iStateWithJasonApi>,
        props: object
    ) => Promise<iJsonApiResponse>;
    propsToWatch: string[];
    stateBranch?: string;
}

interface iRefetchParams {
    cacheQueryResult: (response: iJsonApiResponse) => void;
    fetchData: () => Promise<any>;
    setState: (newState: object) => void;
}

const hashQuery = (actionCreator: any, props: object) =>
    hashObject({
        actionCreator,
        props,
    });

const withQuery = ({
    actionCreator,
    propsToWatch = [],
    stateBranch = 'resourceObjects',
}: iWithQueryOptions) =>
    compose(
        connect(
            (state: iStateWithJasonApi, ownProps) => ({
                cachedQuery: getCachedQuery(
                    state[stateBranch],
                    hashQuery(actionCreator, ownProps)
                ),
            }),
            (dispatch, ownProps) => ({
                fetchData: () => actionCreator(dispatch, ownProps),
                cacheQueryResult: (result: iJsonApiResponse) => {
                    dispatch(
                        cacheQuery(hashQuery(actionCreator, ownProps), result)
                    );
                },
            })
        ),

        withState('state', 'setState', (cachedQuery: iJsonApiResponse) => ({
            isLoading: false,
            queryResult: cachedQuery || {},
        })),

        withHandlers<iRefetchParams, object>({
            refetch: ({
                cacheQueryResult,
                fetchData,
                setState,
            }: iRefetchParams) => () => {
                setState({ isLoading: true });

                fetchData()
                    .then(response => {
                        setState({ isLoading: false });
                        cacheQueryResult(response);
                    })
                    .catch(errors => {
                        setState({ isLoading: false });
                        return errors;
                    });
            },
        }),

        lifecycle({
            componentDidMount() {
                (<any>this.props).refetch();
            },

            componentWillReceiveProps(nextProps) {
                const hasChanged = !equals(
                    pick(propsToWatch, this.props),
                    pick(propsToWatch, nextProps)
                );

                if (!hasChanged) {
                    return;
                }

                (<any>nextProps).refetch();
            },
        }),

        mapProps(omit(['fetchData', 'setLoadingState']))
    );

export default withQuery;
